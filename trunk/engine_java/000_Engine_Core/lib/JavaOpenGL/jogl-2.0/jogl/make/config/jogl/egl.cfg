# This .cfg file is used to generate the interface to the EGL routines
# used internally by the EGLContext implementation.
JavaOutputDir gensrc/classes
NativeOutputDir gensrc/native/jogl/egl

Package com.sun.opengl.impl.egl
JavaClass EGL
Style allstatic
# Shouldn't matter which one of these we pick up
Include egl-common.cfg

HierarchicalNativeOutput false

# Use a ProcAddressTable so we dynamically look up the routines
EmitProcAddressTable true
ProcAddressTableClassName EGLProcAddressTable
GetProcAddressTableExpr _table

# Implement the first argument to eglGetProcAddress as String instead
# of byte[]
ArgumentIsString eglGetProcAddress 0
ReturnsString eglQueryString

CustomCCode #include <EGL/egl.h>

Include ../intptr.cfg

CustomJavaCode EGL  private static EGLProcAddressTable _table = new EGLProcAddressTable();
CustomJavaCode EGL  public static void resetProcAddressTable(DynamicLookupHelper lookup) {
CustomJavaCode EGL      GLProcAddressHelper.resetProcAddressTable(_table, lookup);
CustomJavaCode EGL  }

# There are some #defines in egl.h that GlueGen and PCPP don't currently handle
CustomJavaCode EGL  public static final long EGL_DEFAULT_DISPLAY = 0;
CustomJavaCode EGL  public static final long EGL_NO_CONTEXT = 0;
CustomJavaCode EGL  public static final long EGL_NO_DISPLAY = 0;
CustomJavaCode EGL  public static final long EGL_NO_SURFACE = 0;
CustomJavaCode EGL  public static final int  EGL_DONT_CARE  = -1;
CustomJavaCode EGL  public static final int  EGL_UNKNOWN    = -1;
CustomJavaCode EGL 
CustomJavaCode EGL  protected static long eglGetProcAddress(long eglGetProcAddressHandle, java.lang.String procname)
CustomJavaCode EGL  {
CustomJavaCode EGL    if (eglGetProcAddressHandle == 0) {
CustomJavaCode EGL      throw new GLException("Passed null pointer for method \"eglGetProcAddress\"");
CustomJavaCode EGL    }
CustomJavaCode EGL    return dispatch_eglGetProcAddress0(procname, eglGetProcAddressHandle);
CustomJavaCode EGL  }


Import com.sun.gluegen.runtime.opengl.GLProcAddressHelper
