#summary Flash位图引擎解决方案


== 概述 ==

熟悉flash游戏引擎的人都知道，flash游戏开发中主要用2种渲染方式来实现游戏逻辑。

  # *显示列表*<br>即显示单位为DisplayObject
  # *位图*<br>所有的显示单位都是BitmapData


这里不讨论这2种方式哪个好哪个坏，感兴趣的朋友可以搜索"Flash游戏引擎"。比较有名的有pushbutton engine，flixel，FlashPunk等。

== 位图引擎概念 ==

就是一种基于BitmapData的图像缓冲技术，由开发者来确定图形渲染中，哪些内容该画如何画。可以理解为画画。我们打开一张纸，然后在画面上填充我们想要的东西。适用于大量的单位绘制，比如说粒子系统，射击类游戏，跑酷类游戏。

== 位图引擎的实现 ==

 * 世界 [http://code.google.com/p/cellengine/source/browse/trunk/engine_flash/EngineGFX/src/com/cell/gfx/game/world/CWorld.as CWorld]<br>世界就是一个画布，位图缓冲区，所有游戏世界种的精灵都存在于此。

 * 精灵 [http://code.google.com/p/cellengine/source/browse/trunk/engine_flash/EngineGFX/src/com/cell/gfx/game/world/CWorldSprite.as CWorldSprite]<br>世界中的一个显示对象，比如一发子弹，一架飞机等等。

 * 摄像机 [http://code.google.com/p/cellengine/source/browse/trunk/engine_flash/EngineGFX/src/com/cell/gfx/game/world/CWorldCamera.as CWorldCamera]<br>如果一个世界足够大，那么不可能在一个屏幕里显示所有的精灵，因此需要卷动屏幕显示不同位置的精灵，即卷轴。

{{{
CWorld是一个Bitmap的继承类，主要负责将最终渲染结果显示到Sprite里面。
在CWorld里有一个数组
private var _sprites : Vector.<CWorldSprite> = new Vector.<CWorldSprite>();
该数组实际上就保存了这个世界里的所有的精灵，精灵最终都以BitmapData的形式绘制到CWorld的缓冲区里面。
对于位图引擎来说，摄像机的作用就是计算所有的精灵应该画到世界缓冲区的什么位置。

CWorld的这个函数就是最终将所有精灵绘制到世界缓冲区上。
protected function renderSprites(g:IGraphics, sprites:Vector.<CWorldSprite>) : void
{
	var x1:int = getCameraX();
	var y1:int = getCameraY();
	var x2:int = getCameraX() + getCameraWidth();
	var y2:int = getCameraY() + getCameraHeight();
 			
	for each (var spr : CWorldSprite in sprites)
	{
		if(CMath.intersectRect(
			spr.x + spr.getAnimates().w_left, 
			spr.y + spr.getAnimates().w_top, 
			spr.x + spr.getAnimates().w_right, 
			spr.y + spr.getAnimates().w_bottom, 
			x1, y1, x2, y2))
		{
			spr.render(g, spr.x - x1, spr.y - y1, spr.getCurrentAnimate(), spr.getCurrentFrame());
		}
	}
}

CWorldSprite.render，此方法最终会调用到CWorld的bitmapData的copyPixels方法或draw方法。
这里的sourceBitmapData就是包含在精灵里的图片资源BitmapData，将精灵的图片复制或绘制到世界的缓冲区里。

以上是实现位图引擎的核心思想和逻辑。
}}}


== 使画面动起来 ==
{{{
位图引擎需要每帧都对缓冲区重绘更新，所以EnterFrame事件可以满足这个需求。
在主Sprite里，添加EnterFrame的事件监听。将cworld创建出来后添加到Sprite容器里。
在你的EnterFrame事件里写
public function update(e:Event) : void 
{
	//更新世界中所有精灵的逻辑（比如移动，播放动画帧等等。）
	cworld.update();
	//重绘世界所有精灵
	cworld.render();
}
游戏逻辑需要和渲染逻辑分开以适应比如说暂停时的一些功能。
此时，一个游戏主循环框架就出来了，你只需要管理cworld里所有的精灵的状态来控制游戏逻辑。
}}}